% Optimización Numérica
% ITAM
% Proyecto 2 - PCS
% Andrea Marín Alarcón (158999), Andrea Pérez Vega (154467) 
% y Luis Felipe Landa Elizarralde (158228)


function [x,lambda,k] =  pcsglobal(fx,hx,x0)
% Método de Programación Cuadrática Sucesiva con búsqueda lineal, usando la
% función de mérito L-1 y actualización de la hessiana con la fórmula BFGS
% para el problema:
% Min f(x) s.a. h(x) = 0

% In:
% fx y hx = cadenas de caracteres con las funciones en Matlab de la
% función objetivo y las restricciones del problema.
% x0 = valor inicial
% Out:
% x = aproximación al mínimo local
% lambda = multiplicador de Lagrange asociado a x
% k = número de iteraciones realizadas

m = length(feval(hx, x0));
n = length(x0);
tol = 1e-05;
maxk = 100;
C1 = 1e-02;
C0 = 1;
lambdak = zeros(m,1);
Bk = eye(n);
xk = x0;
k=1;

vk = vertcat(gradiente(fx,xk) + jacobiana(hx,xk)'*lambdak,feval(hx,xk)');

while norm(vk,2) >= tol && k <= maxk
    
    % Resolvemos el subproblema cuadrático
    fk = feval(fx,xk);
    gradfk = gradiente(fx,xk);
    Ak = jacobiana(hx,xk);
    hk = feval(hx,xk);
    
    [pk,~,~,~,lambdak1] = quadprog(Bk, gradfk, [],[], Ak,-hk);
    
    lambdak1 = lambdak1.eqlin;
    
    % Escogemos Ck+1
    C = gradfk'*pk/norm(hk,1);
    
    if C < 0
        C = -1*C;
    end
    
    C = C + 1;
    
    % Calculamos alphak
    alphak = 1;
    phik = fk + C*norm(hk,1);
    Dk = gradfk'*pk - C*norm(hk,1); % Calcular Dpk
    aux = feval(fx,xk+alphak*pk) + C*norm(feval(hx,xk+alphak*pk),1);
    
    while  aux > phik + alphak*C1*Dk
        alphak = alphak/2;
        aux = feval(fx,xk+alphak*pk) + C*norm(feval(hx,xk+alphak*pk),1);
    end
    
    % Actualizamos
    xk1 = xk + alphak*pk;
    sk = xk1 - xk;
    
    % Usamos la forma cerrada del gradiente de la función lagrangiana
    yk = gradiente(fx,xk1) + jacobiana(hx,xk1)'*lambdak1 - gradiente(fx,xk) - jacobiana(hx,xk)'*lambdak1;
    
    % Actualización con Powell
    
    aux = sk'*Bk*sk;
 
    if (sk'*yk > 0.2*aux)
        r = yk;
    else %actualizar el vector r
        theta = (0.8*aux)/(aux - sk'*yk);
        r = theta*yk + (1 - theta)*Bk*sk;
    end
    
    Bk = Bk - ((Bk*sk*sk'*Bk)/aux) + (r*r')/(sk'*r);
 
    %Corregir el error de matrices singulares
    if(rcond(Bk) < 1e-04) 
        Bk = eye(n);
    end
 
    
    % Actualizamos valores
    xk = xk1;
    lambdak = lambdak1;
    k = k + 1;
    
    %Calculamos vk
    vk = vertcat(gradiente(fx,xk) + jacobiana(hx,xk)'*lambdak,feval(hx,xk)');   
    
    
end   

x = xk;
lambda = lambdak1;

end